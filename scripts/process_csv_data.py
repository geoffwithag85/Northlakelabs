#!/usr/bin/env python3
"""
Process CSV files generated by Octave conversion
Combines the CSV data into the JSON format needed for the multi-sensor fusion demo
"""

import pandas as pd
import numpy as np
import json
import glob
from pathlib import Path

def load_csv_files(data_dir):
    """Load all CSV files from the data directory"""
    csv_files = glob.glob(str(data_dir / "*.csv"))
    data = {}
    
    print(f"Found {len(csv_files)} CSV files:")
    
    for csv_file in csv_files:
        filename = Path(csv_file).stem
        print(f"  {filename}")
        
        try:
            df = pd.read_csv(csv_file)
            data[filename] = df
            print(f"    Shape: {df.shape}, Columns: {list(df.columns)}")
        except Exception as e:
            print(f"    Error loading: {e}")
    
    return data

def identify_sensor_data(data):
    """Identify which CSV files contain which sensor data"""
    sensor_mapping = {
        'force_plate': [],
        'imu': [],
        'gait_events_left': [],
        'gait_events_right': [],
        'conditions': []
    }
    
    for filename, df in data.items():
        filename_lower = filename.lower()
        
        if 'fp_' in filename_lower:
            sensor_mapping['force_plate'].append((filename, df))
        elif 'imu_' in filename_lower:
            sensor_mapping['imu'].append((filename, df))
        elif 'gcleft_' in filename_lower:
            sensor_mapping['gait_events_left'].append((filename, df))
        elif 'gcright_' in filename_lower:
            sensor_mapping['gait_events_right'].append((filename, df))
        elif 'conditions_' in filename_lower:
            sensor_mapping['conditions'].append((filename, df))
    
    return sensor_mapping

def process_force_plate_data(fp_data_list):
    """Process force plate CSV data"""
    if not fp_data_list:
        return None
    
    print("\n--- Processing Force Plate Data ---")
    
    # Use the first/largest dataset
    fp_data = max(fp_data_list, key=lambda x: len(x[1]))
    filename, df = fp_data
    
    print(f"Using: {filename}")
    print(f"Columns: {list(df.columns)}")
    
    # Look for time and force columns
    time_col = None
    force_col = None
    
    for col in df.columns:
        col_lower = str(col).lower()
        if 'time' in col_lower or 'header' in col_lower:
            time_col = col
        elif any(term in col_lower for term in ['force', 'fz', 'vertical']):
            force_col = col
    
    # If no specific columns found, use first two columns
    if time_col is None and len(df.columns) >= 2:
        time_col = df.columns[0]
    if force_col is None and len(df.columns) >= 2:
        force_col = df.columns[1] if time_col != df.columns[1] else df.columns[0]
    
    if time_col is not None and force_col is not None:
        # Clean and process the data
        time_data = pd.to_numeric(df[time_col], errors='coerce').dropna()
        force_data = pd.to_numeric(df[force_col], errors='coerce').dropna()
        
        # Ensure same length
        min_len = min(len(time_data), len(force_data))
        time_data = time_data.iloc[:min_len]
        force_data = force_data.iloc[:min_len]
        
        # Limit to 30 seconds max for demo
        if len(time_data) > 30000:  # 30 sec at 1000Hz
            step = len(time_data) // 30000
            time_data = time_data.iloc[::step]
            force_data = force_data.iloc[::step]
        
        print(f"Processed {len(time_data)} samples")
        print(f"Time range: {time_data.iloc[0]:.2f} to {time_data.iloc[-1]:.2f} seconds")
        print(f"Force range: {force_data.min():.1f} to {force_data.max():.1f} N")
        
        return {
            "time": time_data.tolist(),
            "vertical_force": force_data.tolist(),
            "sampling_rate": 1000
        }
    
    return None

def process_imu_data(imu_data_list):
    """Process IMU CSV data"""
    if not imu_data_list:
        return None
    
    print("\n--- Processing IMU Data ---")
    
    # Use the first/largest dataset
    imu_data = max(imu_data_list, key=lambda x: len(x[1]))
    filename, df = imu_data
    
    print(f"Using: {filename}")
    print(f"Columns: {list(df.columns)}")
    
    # Look for time and acceleration columns
    time_col = None
    accel_col = None
    
    for col in df.columns:
        col_lower = str(col).lower()
        if 'time' in col_lower or 'header' in col_lower:
            time_col = col
        elif any(term in col_lower for term in ['accel', 'acc', 'z', 'vertical']):
            accel_col = col
    
    # If no specific columns found, use first two columns
    if time_col is None and len(df.columns) >= 2:
        time_col = df.columns[0]
    if accel_col is None and len(df.columns) >= 2:
        accel_col = df.columns[1] if time_col != df.columns[1] else df.columns[0]
    
    if time_col is not None and accel_col is not None:
        # Clean and process the data
        time_data = pd.to_numeric(df[time_col], errors='coerce').dropna()
        accel_data = pd.to_numeric(df[accel_col], errors='coerce').dropna()
        
        # Ensure same length
        min_len = min(len(time_data), len(accel_data))
        time_data = time_data.iloc[:min_len]
        accel_data = accel_data.iloc[:min_len]
        
        # Limit to 30 seconds max for demo
        if len(time_data) > 6000:  # 30 sec at 200Hz
            step = len(time_data) // 6000
            time_data = time_data.iloc[::step]
            accel_data = accel_data.iloc[::step]
        
        print(f"Processed {len(time_data)} samples")
        print(f"Time range: {time_data.iloc[0]:.2f} to {time_data.iloc[-1]:.2f} seconds")
        print(f"Acceleration range: {accel_data.min():.2f} to {accel_data.max():.2f} m/sÂ²")
        
        return {
            "time": time_data.tolist(),
            "acceleration_z": accel_data.tolist(),
            "sampling_rate": 200
        }
    
    return None

def process_gait_events(left_data_list, right_data_list):
    """Process gait event CSV data"""
    events = []
    
    print("\n--- Processing Gait Events ---")
    
    # Process left leg events
    if left_data_list:
        left_data = left_data_list[0]
        filename, df = left_data
        print(f"Left events from: {filename}")
        
        # Extract timing information
        for i, row in df.iterrows():
            if i > 20:  # Limit number of events for demo
                break
            
            # Try to extract time from first numeric column
            time_val = None
            for col in df.columns:
                try:
                    time_val = float(row[col])
                    if 0 <= time_val <= 100:  # Reasonable time range
                        break
                except:
                    continue
            
            if time_val is not None:
                event_type = "heel_strike" if i % 2 == 0 else "toe_off"
                events.append({
                    "time": time_val,
                    "type": event_type,
                    "leg": "left"
                })
    
    # Process right leg events
    if right_data_list:
        right_data = right_data_list[0]
        filename, df = right_data
        print(f"Right events from: {filename}")
        
        # Extract timing information
        for i, row in df.iterrows():
            if i > 20:  # Limit number of events for demo
                break
            
            # Try to extract time from first numeric column
            time_val = None
            for col in df.columns:
                try:
                    time_val = float(row[col])
                    if 0 <= time_val <= 100:  # Reasonable time range
                        break
                except:
                    continue
            
            if time_val is not None:
                event_type = "heel_strike" if i % 2 == 0 else "toe_off"
                events.append({
                    "time": time_val,
                    "type": event_type,
                    "leg": "right"
                })
    
    # Sort events by time
    events.sort(key=lambda x: x["time"])
    
    print(f"Processed {len(events)} gait events")
    
    return events

def create_demo_json():
    """Main function to create the demo JSON file"""
    print("Multi-Sensor Fusion Demo - CSV to JSON Processor")
    print("=" * 50)
    
    # Load CSV files
    data_dir = Path("src/components/interactive/MultiSensorFusionDemo/data")
    if not data_dir.exists():
        print(f"Error: Data directory not found: {data_dir}")
        print("Run the Octave conversion script first:")
        print("  ./scripts/run_octave_conversion.sh")
        return None
    
    data = load_csv_files(data_dir)
    
    if not data:
        print("No CSV files found. Run the Octave conversion first.")
        return None
    
    # Identify sensor data
    sensor_mapping = identify_sensor_data(data)
    
    # Process each sensor type
    demo_data = {
        "trial_info": {
            "subject": "AB09",  # From dataset
            "condition": "levelground_normal",
            "duration": 30.0,  # Will be updated based on actual data
            "citation": "Camargo et al. 2021, DOI: 10.1016/j.jbiomech.2021.110320"
        }
    }
    
    # Process force plate data
    fp_data = process_force_plate_data(sensor_mapping['force_plate'])
    if fp_data:
        demo_data["force_plate"] = fp_data
        # Update duration based on force plate data
        if fp_data["time"]:
            demo_data["trial_info"]["duration"] = max(fp_data["time"])
    
    # Process IMU data
    imu_data = process_imu_data(sensor_mapping['imu'])
    if imu_data:
        demo_data["imu"] = imu_data
    
    # Process gait events
    gait_events = process_gait_events(
        sensor_mapping['gait_events_left'],
        sensor_mapping['gait_events_right']
    )
    demo_data["ground_truth_events"] = gait_events
    
    # Save to JSON
    output_file = data_dir / "demo-trial.json"
    
    try:
        with open(output_file, 'w') as f:
            json.dump(demo_data, f, indent=2)
        
        print(f"\n=== SUCCESS ===")
        print(f"Demo data exported to: {output_file}")
        print(f"Trial duration: {demo_data['trial_info']['duration']:.1f}s")
        print(f"Force plate samples: {len(demo_data.get('force_plate', {}).get('time', []))}")
        print(f"IMU samples: {len(demo_data.get('imu', {}).get('time', []))}")
        print(f"Gait events: {len(demo_data['ground_truth_events'])}")
        
        return output_file
        
    except Exception as e:
        print(f"Error saving JSON: {e}")
        return None

if __name__ == "__main__":
    create_demo_json()